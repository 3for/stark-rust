/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type conditional_type<_If> = _If;
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        pub type pair__EnableB = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct pair__CheckArgs {
            pub _address: u8,
        }
        pub type pair__CheckArgsDep = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct pair__CheckTupleLikeConstructor {
            pub _address: u8,
        }
        pub type pair__CheckTLC = u8;
        pub type streampos = root::std::fpos<root::mbstate_t>;
        pub type streamoff = ::std::os::raw::c_longlong;
        pub type string = root::std::basic_string;
        #[repr(C)]
        #[derive(Debug)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        pub type iterator_iterator_category<_Category> = _Category;
        #[repr(C)]
        #[derive(Debug)]
        pub struct reverse_iterator<_Iter> {
            pub __t: _Iter,
            pub current: _Iter,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
        }
        pub type reverse_iterator_iterator_type<_Iter> = _Iter;
        pub type reverse_iterator_difference_type = root::std::iterator_traits;
        pub type reverse_iterator_reference = root::std::iterator_traits;
        pub type reverse_iterator_pointer = root::std::iterator_traits;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __wrap_iter<_Iter> {
            pub __i: root::std::__wrap_iter_iterator_type<_Iter>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
        }
        pub type __wrap_iter_iterator_type<_Iter> = _Iter;
        pub type __wrap_iter_iterator_category = root::std::iterator_traits;
        pub type __wrap_iter_value_type = root::std::iterator_traits;
        pub type __wrap_iter_difference_type = root::std::iterator_traits;
        pub type __wrap_iter_pointer = root::std::iterator_traits;
        pub type __wrap_iter_reference = root::std::iterator_traits;
        pub type __pointer_traits_difference_type_type = isize;
        pub type __pointer_traits_rebind_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_element_type = u8;
        pub type pointer_traits_difference_type = u8;
        pub type pointer_traits_rebind = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct pointer_traits___nat {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __rebind_pointer {
            pub _address: u8,
        }
        pub type __rebind_pointer_type = root::std::pointer_traits;
        pub mod __pointer_type_imp {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type __pointer_type_type = [u8; 0usize];
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __pointer_type {
            pub _address: u8,
        }
        pub type __pointer_type_type = u8;
        pub type __propagate_on_container_copy_assignment_type = root::std::false_type;
        pub type __propagate_on_container_move_assignment_type = root::std::false_type;
        pub type __propagate_on_container_swap_type = root::std::false_type;
        pub type __is_always_equal_type = root::std::is_empty;
        pub type __allocator_traits_rebind_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = [u8; 0usize];
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = [u8; 0usize];
        pub type allocator_traits_const_void_pointer = [u8; 0usize];
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment = u8;
        pub type allocator_traits_propagate_on_container_move_assignment = u8;
        pub type allocator_traits_propagate_on_container_swap = u8;
        pub type allocator_traits_is_always_equal = u8;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __rebind_alloc_helper {
            pub _address: u8,
        }
        pub type __rebind_alloc_helper_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type __compressed_pair_elem__ParamT<_Tp> = _Tp;
        pub type __compressed_pair_elem_reference<_Tp> = *mut _Tp;
        pub type __compressed_pair_elem_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __compressed_pair {
            pub _address: u8,
        }
        pub type __compressed_pair__Base1 = u8;
        pub type __compressed_pair__Base2 = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __unique_ptr_deleter_sfinae {
            pub _address: u8,
        }
        pub type __unique_ptr_deleter_sfinae___lval_ref_type<_Deleter> = *const _Deleter;
        pub type __unique_ptr_deleter_sfinae___good_rval_ref_type<_Deleter> = *mut _Deleter;
        pub type __unique_ptr_deleter_sfinae___enable_rval_overload = root::std::true_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_ptr {
            pub __ptr_: root::std::__compressed_pair,
        }
        pub type unique_ptr_element_type<_Tp> = _Tp;
        pub type unique_ptr_deleter_type<_Dp> = _Dp;
        pub type unique_ptr_pointer = root::std::__pointer_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_ptr___nat {
            pub __for_bool_: ::std::os::raw::c_int,
        }
        pub type unique_ptr__DeleterSFINAE = root::std::__unique_ptr_deleter_sfinae;
        pub type unique_ptr__LValRefType = u8;
        pub type unique_ptr__GoodRValRefType = u8;
        pub type unique_ptr__BadRValRefType = u8;
        pub type unique_ptr__EnableIfDeleterDefaultConstructible = u8;
        pub type unique_ptr__EnableIfDeleterConstructible = u8;
        pub type unique_ptr__EnableIfMoveConvertible = u8;
        pub type unique_ptr__EnableIfDeleterConvertible = u8;
        pub type unique_ptr__EnableIfDeleterAssignable = u8;
        extern "C" {
            #[link_name = "\u{1}__throw_length_error"]
            pub fn __vector_base_common___throw_length_error(this: *const u8);
        }
        extern "C" {
            #[link_name = "\u{1}__throw_out_of_range"]
            pub fn __vector_base_common___throw_out_of_range(this: *const u8);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __vector_base {
            pub _base: u8,
            pub __begin_: root::std::__vector_base_pointer,
            pub __end_: root::std::__vector_base_pointer,
            pub __end_cap_: root::std::__compressed_pair,
        }
        pub type __vector_base_value_type<_Tp> = _Tp;
        pub type __vector_base_allocator_type<_Allocator> = _Allocator;
        pub type __vector_base___alloc_traits = root::std::allocator_traits;
        pub type __vector_base_reference<_Tp> = *mut root::std::__vector_base_value_type<_Tp>;
        pub type __vector_base_const_reference<_Tp> =
            *const root::std::__vector_base_value_type<_Tp>;
        pub type __vector_base_size_type = root::std::__vector_base___alloc_traits;
        pub type __vector_base_difference_type = root::std::__vector_base___alloc_traits;
        pub type __vector_base_pointer = root::std::__vector_base___alloc_traits;
        pub type __vector_base_const_pointer = root::std::__vector_base___alloc_traits;
        pub type __vector_base_iterator = root::std::__vector_base_pointer;
        pub type __vector_base_const_iterator = root::std::__vector_base_const_pointer;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _base: root::std::__vector_base,
        }
        pub type vector___base = root::std::__vector_base;
        pub type vector___default_allocator_type = root::std::allocator;
        pub type vector___self = root::std::vector;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_allocator_type<_Allocator> = _Allocator;
        pub type vector___alloc_traits = root::std::vector___base;
        pub type vector_reference = root::std::vector___base;
        pub type vector_const_reference = root::std::vector___base;
        pub type vector_size_type = root::std::vector___base;
        pub type vector_difference_type = root::std::vector___base;
        pub type vector_pointer = root::std::vector___base;
        pub type vector_const_pointer = root::std::vector___base;
        pub type vector_iterator = root::std::__wrap_iter<root::std::vector_pointer>;
        pub type vector_const_iterator = root::std::__wrap_iter<root::std::vector_const_pointer>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector___RAII_IncreaseAnnotator {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = ::std::os::raw::c_int;
        pub type char_traits_off_type = root::std::streamoff;
        pub type char_traits_pos_type = root::std::streampos;
        pub type char_traits_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_string_view<_CharT> {
            pub __data: *const root::std::basic_string_view_value_type<_CharT>,
            pub __size: root::std::basic_string_view_size_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string_view_traits_type<_Traits> = _Traits;
        pub type basic_string_view_value_type<_CharT> = _CharT;
        pub type basic_string_view_pointer<_CharT> = *mut _CharT;
        pub type basic_string_view_const_pointer<_CharT> = *const _CharT;
        pub type basic_string_view_reference<_CharT> = *mut _CharT;
        pub type basic_string_view_const_reference<_CharT> = *const _CharT;
        pub type basic_string_view_const_iterator<_CharT> =
            root::std::basic_string_view_const_pointer<_CharT>;
        pub type basic_string_view_iterator<_CharT> =
            root::std::basic_string_view_const_iterator<_CharT>;
        pub type basic_string_view_const_reverse_iterator<_CharT> =
            root::std::reverse_iterator<root::std::basic_string_view_const_iterator<_CharT>>;
        pub type basic_string_view_reverse_iterator<_CharT> =
            root::std::basic_string_view_const_reverse_iterator<_CharT>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        #[repr(C)]
        #[derive(Debug)]
        pub struct fpos<_StateT> {
            pub __st_: _StateT,
            pub __off_: root::std::streamoff,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        extern "C" {
            #[link_name = "\u{1}__throw_length_error"]
            pub fn __basic_string_common___throw_length_error(this: *const u8);
        }
        extern "C" {
            #[link_name = "\u{1}__throw_out_of_range"]
            pub fn __basic_string_common___throw_out_of_range(this: *const u8);
        }
        #[repr(C)]
        pub struct basic_string {
            pub _base: u8,
            pub __r_: root::std::__compressed_pair,
        }
        pub type basic_string___self = root::std::basic_string;
        pub type basic_string___self_view<_CharT> = root::std::basic_string_view<_CharT>;
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type<_CharT> = _CharT;
        pub type basic_string_allocator_type<_Allocator> = _Allocator;
        pub type basic_string___alloc_traits = root::std::allocator_traits;
        pub type basic_string_size_type = root::std::basic_string___alloc_traits;
        pub type basic_string_difference_type = root::std::basic_string___alloc_traits;
        pub type basic_string_reference<_CharT> = *mut root::std::basic_string_value_type<_CharT>;
        pub type basic_string_const_reference<_CharT> =
            *const root::std::basic_string_value_type<_CharT>;
        pub type basic_string_pointer = root::std::basic_string___alloc_traits;
        pub type basic_string_const_pointer = root::std::basic_string___alloc_traits;
        pub type basic_string_iterator = root::std::__wrap_iter<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::std::__wrap_iter<root::std::basic_string_const_pointer>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_string___long {
            pub __cap_: root::std::basic_string_size_type,
            pub __size_: root::std::basic_string_size_type,
            pub __data_: root::std::basic_string_pointer,
        }
        pub const basic_string___min_cap: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        pub struct basic_string___short<_CharT> {
            pub __bindgen_anon_1: root::std::basic_string___short__bindgen_ty_1<_CharT>,
            pub __data_: *mut root::std::basic_string_value_type<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        #[repr(C)]
        pub struct basic_string___short__bindgen_ty_1<_CharT> {
            pub __size_: root::__BindgenUnionField<::std::os::raw::c_uchar>,
            pub __lx: root::__BindgenUnionField<root::std::basic_string_value_type>,
            pub bindgen_union_field: u8,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        #[repr(C)]
        pub struct basic_string___ulx<_CharT> {
            pub __lx: root::__BindgenUnionField<root::std::basic_string___long>,
            pub __lxx: root::__BindgenUnionField<root::std::basic_string___short>,
            pub bindgen_union_field: [u8; 0usize],
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub const basic_string___n_words: root::std::basic_string__bindgen_ty_2 = 0;
        pub type basic_string__bindgen_ty_2 = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_string___raw {
            pub __words: *mut root::std::basic_string_size_type,
        }
        #[repr(C)]
        pub struct basic_string___rep<_CharT> {
            pub __bindgen_anon_1: root::std::basic_string___rep__bindgen_ty_1<_CharT>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        #[repr(C)]
        pub struct basic_string___rep__bindgen_ty_1<_CharT> {
            pub __l: root::__BindgenUnionField<root::std::basic_string___long>,
            pub __s: root::__BindgenUnionField<root::std::basic_string___short>,
            pub __r: root::__BindgenUnionField<root::std::basic_string___raw>,
            pub bindgen_union_field: [u8; 0usize],
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub const basic_string___alignment: root::std::basic_string__bindgen_ty_3 = 0;
        pub type basic_string__bindgen_ty_3 = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __tree_node_types {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __make_tree_node_types {
            pub _address: u8,
        }
        pub type __make_tree_node_types__NodePtr = root::std::__rebind_pointer;
        pub type __make_tree_node_types_type = root::std::__tree_node_types;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __tree_node_destructor<_Allocator> {
            pub __na_: *mut root::std::__tree_node_destructor_allocator_type<_Allocator>,
            pub __value_constructed: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Allocator>>,
        }
        pub type __tree_node_destructor_allocator_type<_Allocator> = _Allocator;
        pub type __tree_node_destructor___alloc_traits = root::std::allocator_traits;
        pub type __tree_node_destructor_pointer = root::std::__tree_node_destructor___alloc_traits;
        pub type __tree_node_destructor__NodeTypes = root::std::__tree_node_types;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __tree_iterator {
            pub __ptr_: root::std::__tree_iterator___iter_pointer,
        }
        pub type __tree_iterator__NodeTypes = root::std::__tree_node_types;
        pub type __tree_iterator___node_pointer<_NodePtr> = _NodePtr;
        pub type __tree_iterator___node_base_pointer = root::std::__tree_iterator__NodeTypes;
        pub type __tree_iterator___end_node_pointer = root::std::__tree_iterator__NodeTypes;
        pub type __tree_iterator___iter_pointer = root::std::__tree_iterator__NodeTypes;
        pub type __tree_iterator___pointer_traits = root::std::pointer_traits;
        pub type __tree_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type __tree_iterator_value_type<_Tp> = _Tp;
        pub type __tree_iterator_difference_type<_DiffType> = _DiffType;
        pub type __tree_iterator_reference<_Tp> = *mut root::std::__tree_iterator_value_type<_Tp>;
        pub type __tree_iterator_pointer = root::std::__tree_iterator__NodeTypes;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __tree_const_iterator {
            pub __ptr_: root::std::__tree_const_iterator___iter_pointer,
        }
        pub type __tree_const_iterator__NodeTypes = root::std::__tree_node_types;
        pub type __tree_const_iterator___node_pointer = root::std::__tree_const_iterator__NodeTypes;
        pub type __tree_const_iterator___node_base_pointer =
            root::std::__tree_const_iterator__NodeTypes;
        pub type __tree_const_iterator___end_node_pointer =
            root::std::__tree_const_iterator__NodeTypes;
        pub type __tree_const_iterator___iter_pointer = root::std::__tree_const_iterator__NodeTypes;
        pub type __tree_const_iterator___pointer_traits = root::std::pointer_traits;
        pub type __tree_const_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type __tree_const_iterator_value_type<_Tp> = _Tp;
        pub type __tree_const_iterator_difference_type<_DiffType> = _DiffType;
        pub type __tree_const_iterator_reference<_Tp> =
            *const root::std::__tree_const_iterator_value_type<_Tp>;
        pub type __tree_const_iterator_pointer = root::std::__tree_const_iterator__NodeTypes;
        pub type __tree_const_iterator___non_const_iterator = root::std::__tree_iterator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __tree {
            pub __begin_node_: root::std::__tree___iter_pointer,
            pub __pair1_: root::std::__compressed_pair,
            pub __pair3_: root::std::__compressed_pair,
        }
        pub type __tree_value_type<_Tp> = _Tp;
        pub type __tree_value_compare<_Compare> = _Compare;
        pub type __tree_allocator_type<_Allocator> = _Allocator;
        pub type __tree___alloc_traits = root::std::allocator_traits;
        pub type __tree__NodeTypes = root::std::__make_tree_node_types;
        pub type __tree_key_type = root::std::__tree__NodeTypes;
        pub type __tree___node_value_type = root::std::__tree__NodeTypes;
        pub type __tree___container_value_type = root::std::__tree__NodeTypes;
        pub type __tree_pointer = root::std::__tree___alloc_traits;
        pub type __tree_const_pointer = root::std::__tree___alloc_traits;
        pub type __tree_size_type = root::std::__tree___alloc_traits;
        pub type __tree_difference_type = root::std::__tree___alloc_traits;
        pub type __tree___void_pointer = root::std::__tree__NodeTypes;
        pub type __tree___node = root::std::__tree__NodeTypes;
        pub type __tree___node_pointer = root::std::__tree__NodeTypes;
        pub type __tree___node_base = root::std::__tree__NodeTypes;
        pub type __tree___node_base_pointer = root::std::__tree__NodeTypes;
        pub type __tree___end_node_t = root::std::__tree__NodeTypes;
        pub type __tree___end_node_ptr = root::std::__tree__NodeTypes;
        pub type __tree___parent_pointer = root::std::__tree__NodeTypes;
        pub type __tree___iter_pointer = root::std::__tree__NodeTypes;
        pub type __tree___node_allocator = root::std::__rebind_alloc_helper;
        pub type __tree___node_traits = root::std::allocator_traits;
        pub type __tree___node_base_allocator = root::std::__rebind_alloc_helper;
        pub type __tree___node_base_traits = root::std::allocator_traits;
        pub type __tree__Dp = root::std::__tree_node_destructor<root::std::__tree___node_allocator>;
        pub type __tree___node_holder = root::std::unique_ptr;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __map_node_destructor<_Allocator> {
            pub __na_: *mut root::std::__map_node_destructor_allocator_type<_Allocator>,
            pub __first_constructed: bool,
            pub __second_constructed: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Allocator>>,
        }
        pub type __map_node_destructor_allocator_type<_Allocator> = _Allocator;
        pub type __map_node_destructor___alloc_traits = root::std::allocator_traits;
        pub type __map_node_destructor_pointer = root::std::__map_node_destructor___alloc_traits;
        #[repr(C)]
        pub struct __value_type<_Key, _Tp> {
            pub __cc: root::__BindgenUnionField<root::std::__value_type_value_type>,
            pub __nc: root::__BindgenUnionField<root::std::__value_type___nc_value_type>,
            pub bindgen_union_field: [u8; 0usize],
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Key>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        pub type __value_type_key_type<_Key> = _Key;
        pub type __value_type_mapped_type<_Tp> = _Tp;
        pub type __value_type_value_type<_Key, _Tp> = root::std::pair<
            root::std::__value_type_key_type<_Key>,
            root::std::__value_type_mapped_type<_Tp>,
        >;
        pub type __value_type___nc_value_type<_Key, _Tp> = root::std::pair<
            root::std::__value_type_key_type<_Key>,
            root::std::__value_type_mapped_type<_Tp>,
        >;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __map_iterator<_TreeIterator> {
            pub __i_: _TreeIterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_TreeIterator>>,
        }
        pub type __map_iterator__NodeTypes = [u8; 0usize];
        pub type __map_iterator___pointer_traits = [u8; 0usize];
        pub type __map_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type __map_iterator_value_type = [u8; 0usize];
        pub type __map_iterator_difference_type = [u8; 0usize];
        pub type __map_iterator_reference = *mut root::std::__map_iterator_value_type;
        pub type __map_iterator_pointer = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct __map_const_iterator<_TreeIterator> {
            pub __i_: _TreeIterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_TreeIterator>>,
        }
        pub type __map_const_iterator__NodeTypes = [u8; 0usize];
        pub type __map_const_iterator___pointer_traits = [u8; 0usize];
        pub type __map_const_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type __map_const_iterator_value_type = [u8; 0usize];
        pub type __map_const_iterator_difference_type = [u8; 0usize];
        pub type __map_const_iterator_reference = *const root::std::__map_const_iterator_value_type;
        pub type __map_const_iterator_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct map {
            pub __tree_: root::std::map___base,
        }
        pub type map_key_type<_Key> = _Key;
        pub type map_mapped_type<_Tp> = _Tp;
        pub type map_value_type<_Key, _Tp> =
            root::std::pair<root::std::map_key_type<_Key>, root::std::map_mapped_type<_Tp>>;
        pub type map___nc_value_type<_Key, _Tp> =
            root::std::pair<root::std::map_key_type<_Key>, root::std::map_mapped_type<_Tp>>;
        pub type map_key_compare<_Compare> = _Compare;
        pub type map_allocator_type<_Allocator> = _Allocator;
        pub type map_reference<_Key, _Tp> = *mut root::std::map_value_type<_Key, _Tp>;
        pub type map_const_reference<_Key, _Tp> = *const root::std::map_value_type<_Key, _Tp>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct map_value_compare<_Compare> {
            pub comp: root::std::map_key_compare<_Compare>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
        }
        pub type map___value_type<_Key, _Tp> =
            root::std::__value_type<root::std::map_key_type<_Key>, root::std::map_mapped_type<_Tp>>;
        pub type map___vc = u8;
        pub type map___allocator_type = root::std::__rebind_alloc_helper;
        pub type map___base = root::std::__tree;
        pub type map___node_traits = root::std::map___base;
        pub type map___alloc_traits = root::std::allocator_traits;
        pub type map_pointer = root::std::map___alloc_traits;
        pub type map_const_pointer = root::std::map___alloc_traits;
        pub type map_size_type = root::std::map___alloc_traits;
        pub type map_difference_type = root::std::map___alloc_traits;
        pub type map_iterator = root::std::__map_iterator<root::std::map___base>;
        pub type map_const_iterator = root::std::__map_const_iterator<root::std::map___base>;
        pub type map_reverse_iterator = root::std::reverse_iterator<root::std::map_iterator>;
        pub type map_const_reverse_iterator =
            root::std::reverse_iterator<root::std::map_const_iterator>;
        pub type map___node = root::std::map___base;
        pub type map___node_allocator = root::std::map___base;
        pub type map___node_pointer = root::std::map___base;
        pub type map___node_base_pointer = root::std::map___base;
        pub type map___parent_pointer = root::std::map___base;
        pub type map__Dp = root::std::__map_node_destructor<root::std::map___node_allocator>;
        pub type map___node_holder = root::std::unique_ptr;
    }
    #[repr(C)]
    pub struct __mbstate_t {
        pub __mbstate8: root::__BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
        pub _mbstateL: root::__BindgenUnionField<::std::os::raw::c_longlong>,
        pub bindgen_union_field: [u64; 16usize],
    }
    pub type __darwin_mbstate_t = root::__mbstate_t;
    pub type mbstate_t = root::__darwin_mbstate_t;
    pub mod FFF {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type idx_t = ::std::os::raw::c_ulonglong;
        pub type len_t = ::std::os::raw::c_uint;
        pub type cell_t = ::std::os::raw::c_ulonglong;
        #[repr(C)]
        #[derive(Debug)]
        pub struct Element {
            pub c: [root::FFF::cell_t; 1usize],
        }
        pub const Element_log_bits_in_byte: ::std::os::raw::c_uint = 3;
        pub const Element_bits_in_byte: ::std::os::raw::c_uint = 8;
        pub const Element_log_ord: ::std::os::raw::c_uint = 6;
        pub const Element_ord: ::std::os::raw::c_uint = 64;
        pub const Element_log_bits_in_cell: ::std::os::raw::c_uint = 6;
        pub const Element_bits_in_cell: ::std::os::raw::c_uint = 64;
        pub const Element_element_len: ::std::os::raw::c_uint = 1;
        extern "C" {
            #[link_name = "\u{1}irr_poly_index"]
            pub static mut Element_irr_poly_index: [[root::FFF::idx_t; 5usize]; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}irr_poly_e"]
            pub static mut Element_irr_poly_e: [[root::FFF::cell_t; 1usize]; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}mod_len"]
            pub static mut Element_mod_len: [root::FFF::len_t; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}generateOrdElement"]
            pub fn Element_generateOrdElement(e: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}clmulXor"]
            pub fn Element_clmulXor(
                a: *const root::FFF::cell_t,
                b: *const root::FFF::cell_t,
                res: *mut root::FFF::cell_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}reduce"]
            pub fn Element_reduce(clmul_res: *mut root::FFF::cell_t, res: *mut root::FFF::cell_t);
        }
        extern "C" {
            #[link_name = "\u{1}clmul"]
            pub fn Element_clmul(
                a: *const root::FFF::cell_t,
                b: *const root::FFF::cell_t,
                res: *mut root::FFF::cell_t,
            );
        }
        extern "C" {
            /// Constant Memory Settings
            #[link_name = "\u{1}setMod"]
            pub fn Element_setMod();
        }
        extern "C" {
            /// Chunk/Vector Operations
            #[link_name = "\u{1}equals"]
            pub fn Element_equals(a: *mut root::FFF::Element, b: *mut root::FFF::Element) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}equals"]
            pub fn Element_equals1(a: *mut root::FFF::Element, b: *mut root::FFF::Element) -> bool;
        }
        extern "C" {
            /// CPU Operations
            #[link_name = "\u{1}setElementMul"]
            pub fn Element_setElementMul(e: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_add"]
            pub fn Element_c_add(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}c_add"]
            pub fn Element_c_add1(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}c_mul"]
            pub fn Element_c_mul(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}c_mul"]
            pub fn Element_c_mul1(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}c_mulXor"]
            pub fn Element_c_mulXor(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}do_FFT_step"]
            pub fn Element_do_FFT_step(
                factor: *const root::FFF::Element,
                a: *mut root::FFF::Element,
                b: *mut root::FFF::Element,
                len: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}c_sqr"]
            pub fn Element_c_sqr(a: *mut root::FFF::Element, c: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_sqr"]
            pub fn Element_c_sqr1(a: *mut root::FFF::Element, c: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_exp"]
            pub fn Element_c_exp(
                a: root::FFF::Element,
                exp: ::std::os::raw::c_ulonglong,
                res: *mut root::FFF::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}c_inv"]
            pub fn Element_c_inv(a: *mut root::FFF::Element, c: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_inv"]
            pub fn Element_c_inv1(a: *mut root::FFF::Element, res: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_setZero"]
            pub fn Element_c_setZero(a: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_setZero"]
            pub fn Element_c_setZero1(a: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_isZero"]
            pub fn Element_c_isZero(a: *mut root::FFF::Element) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}c_setUnit"]
            pub fn Element_c_setUnit(a: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_setUnit"]
            pub fn Element_c_setUnit1(a: *mut root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}c_isUnit"]
            pub fn Element_c_isUnit(a: *mut root::FFF::Element) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}c_isUnit"]
            pub fn Element_c_isUnit1(a: *mut root::FFF::Element) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}c_vecMul"]
            pub fn Element_c_vecMul(
                a: *mut root::FFF::Element,
                b: *mut root::FFF::Element,
                c: *mut root::FFF::Element,
                l: root::FFF::len_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}vecXor"]
            pub fn Element_vecXor(
                a: *mut root::FFF::cell_t,
                b: *mut root::FFF::cell_t,
                len: root::FFF::len_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}vecXor"]
            pub fn Element_vecXor1(
                a: *mut root::FFF::cell_t,
                b: *mut root::FFF::cell_t,
                c: *mut root::FFF::cell_t,
                len: root::FFF::len_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}assign_cells"]
            pub fn Element_assign_cells(
                a: *mut root::FFF::cell_t,
                b: *mut root::FFF::cell_t,
                len: root::FFF::len_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}assign"]
            pub fn Element_assign(a: *mut root::FFF::Element, b: *const root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}assign"]
            pub fn Element_assign1(a: *mut root::FFF::Element, b: *const root::FFF::Element);
        }
        extern "C" {
            /// Testing and Representation
            #[link_name = "\u{1}printCells"]
            pub fn Element_printCells(x: *const root::FFF::cell_t, l: root::FFF::len_t);
        }
        extern "C" {
            #[link_name = "\u{1}printElement"]
            pub fn Element_printElement(x: *const root::FFF::Element);
        }
        extern "C" {
            #[link_name = "\u{1}naiveMul"]
            pub fn Element_naiveMul(
                a: *const root::FFF::cell_t,
                b: *const root::FFF::cell_t,
                c: *mut root::FFF::cell_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}naiveMul"]
            pub fn Element_naiveMul1(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}Element"]
            pub fn Element_Element(this: *mut root::FFF::Element, e: *const root::FFF::Element);
        }
        impl Element {
            #[inline]
            pub unsafe fn generateOrdElement(e: *mut root::FFF::Element) {
                Element_generateOrdElement(e)
            }
            #[inline]
            pub unsafe fn clmulXor(
                a: *const root::FFF::cell_t,
                b: *const root::FFF::cell_t,
                res: *mut root::FFF::cell_t,
            ) {
                Element_clmulXor(a, b, res)
            }
            #[inline]
            pub unsafe fn reduce(clmul_res: *mut root::FFF::cell_t, res: *mut root::FFF::cell_t) {
                Element_reduce(clmul_res, res)
            }
            #[inline]
            pub unsafe fn clmul(
                a: *const root::FFF::cell_t,
                b: *const root::FFF::cell_t,
                res: *mut root::FFF::cell_t,
            ) {
                Element_clmul(a, b, res)
            }
            #[inline]
            pub unsafe fn setMod() {
                Element_setMod()
            }
            #[inline]
            pub unsafe fn equals(a: *mut root::FFF::Element, b: *mut root::FFF::Element) -> bool {
                Element_equals(a, b)
            }
            #[inline]
            pub unsafe fn equals1(a: *mut root::FFF::Element, b: *mut root::FFF::Element) -> bool {
                Element_equals1(a, b)
            }
            #[inline]
            pub unsafe fn setElementMul(e: *mut root::FFF::Element) {
                Element_setElementMul(e)
            }
            #[inline]
            pub unsafe fn c_add(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            ) {
                Element_c_add(a, b, c)
            }
            #[inline]
            pub unsafe fn c_add1(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            ) {
                Element_c_add1(a, b, c)
            }
            #[inline]
            pub unsafe fn c_mul(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            ) {
                Element_c_mul(a, b, c)
            }
            #[inline]
            pub unsafe fn c_mul1(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            ) {
                Element_c_mul1(a, b, c)
            }
            #[inline]
            pub unsafe fn c_mulXor(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            ) {
                Element_c_mulXor(a, b, c)
            }
            #[inline]
            pub unsafe fn do_FFT_step(
                factor: *const root::FFF::Element,
                a: *mut root::FFF::Element,
                b: *mut root::FFF::Element,
                len: ::std::os::raw::c_int,
            ) {
                Element_do_FFT_step(factor, a, b, len)
            }
            #[inline]
            pub unsafe fn c_sqr(a: *mut root::FFF::Element, c: *mut root::FFF::Element) {
                Element_c_sqr(a, c)
            }
            #[inline]
            pub unsafe fn c_sqr1(a: *mut root::FFF::Element, c: *mut root::FFF::Element) {
                Element_c_sqr1(a, c)
            }
            #[inline]
            pub unsafe fn c_exp(
                a: root::FFF::Element,
                exp: ::std::os::raw::c_ulonglong,
                res: *mut root::FFF::Element,
            ) {
                Element_c_exp(a, exp, res)
            }
            #[inline]
            pub unsafe fn c_inv(a: *mut root::FFF::Element, c: *mut root::FFF::Element) {
                Element_c_inv(a, c)
            }
            #[inline]
            pub unsafe fn c_inv1(a: *mut root::FFF::Element, res: *mut root::FFF::Element) {
                Element_c_inv1(a, res)
            }
            #[inline]
            pub unsafe fn c_setZero(a: *mut root::FFF::Element) {
                Element_c_setZero(a)
            }
            #[inline]
            pub unsafe fn c_setZero1(a: *mut root::FFF::Element) {
                Element_c_setZero1(a)
            }
            #[inline]
            pub unsafe fn c_isZero(a: *mut root::FFF::Element) -> bool {
                Element_c_isZero(a)
            }
            #[inline]
            pub unsafe fn c_setUnit(a: *mut root::FFF::Element) {
                Element_c_setUnit(a)
            }
            #[inline]
            pub unsafe fn c_setUnit1(a: *mut root::FFF::Element) {
                Element_c_setUnit1(a)
            }
            #[inline]
            pub unsafe fn c_isUnit(a: *mut root::FFF::Element) -> bool {
                Element_c_isUnit(a)
            }
            #[inline]
            pub unsafe fn c_isUnit1(a: *mut root::FFF::Element) -> bool {
                Element_c_isUnit1(a)
            }
            #[inline]
            pub unsafe fn c_vecMul(
                a: *mut root::FFF::Element,
                b: *mut root::FFF::Element,
                c: *mut root::FFF::Element,
                l: root::FFF::len_t,
            ) {
                Element_c_vecMul(a, b, c, l)
            }
            #[inline]
            pub unsafe fn vecXor(
                a: *mut root::FFF::cell_t,
                b: *mut root::FFF::cell_t,
                len: root::FFF::len_t,
            ) {
                Element_vecXor(a, b, len)
            }
            #[inline]
            pub unsafe fn vecXor1(
                a: *mut root::FFF::cell_t,
                b: *mut root::FFF::cell_t,
                c: *mut root::FFF::cell_t,
                len: root::FFF::len_t,
            ) {
                Element_vecXor1(a, b, c, len)
            }
            #[inline]
            pub unsafe fn assign_cells(
                a: *mut root::FFF::cell_t,
                b: *mut root::FFF::cell_t,
                len: root::FFF::len_t,
            ) {
                Element_assign_cells(a, b, len)
            }
            #[inline]
            pub unsafe fn assign(a: *mut root::FFF::Element, b: *const root::FFF::Element) {
                Element_assign(a, b)
            }
            #[inline]
            pub unsafe fn assign1(a: *mut root::FFF::Element, b: *const root::FFF::Element) {
                Element_assign1(a, b)
            }
            #[inline]
            pub unsafe fn printCells(x: *const root::FFF::cell_t, l: root::FFF::len_t) {
                Element_printCells(x, l)
            }
            #[inline]
            pub unsafe fn printElement(x: *const root::FFF::Element) {
                Element_printElement(x)
            }
            #[inline]
            pub unsafe fn naiveMul(
                a: *const root::FFF::cell_t,
                b: *const root::FFF::cell_t,
                c: *mut root::FFF::cell_t,
            ) {
                Element_naiveMul(a, b, c)
            }
            #[inline]
            pub unsafe fn naiveMul1(
                a: *const root::FFF::Element,
                b: *const root::FFF::Element,
                c: *mut root::FFF::Element,
            ) {
                Element_naiveMul1(a, b, c)
            }
            #[inline]
            pub unsafe fn new(e: *const root::FFF::Element) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Element_Element(&mut __bindgen_tmp, e);
                __bindgen_tmp
            }
        }
    }
    pub mod Algebra {
        #[allow(unused_imports)]
        use self::super::super::root;
        /// @class FieldElement
        #[repr(C)]
        #[derive(Debug)]
        pub struct FieldElement {
            ///< @brief instance state
            pub element_: root::FFF::Element,
        }
        pub const FieldElement_numBits: ::std::os::raw::c_short = 64;
        extern "C" {
            /// element_ as string
            #[link_name = "\u{1}asString"]
            pub fn FieldElement_asString(
                this: *const root::Algebra::FieldElement,
            ) -> root::std::string;
        }
        impl FieldElement {
            #[inline]
            pub unsafe fn asString(&self) -> root::std::string {
                FieldElement_asString(self)
            }
        }
        /// @class PolynomialDegree
        /// @brief The degree of a polynomial can
        /// be a natural integer, or \f$ -\infty\f$
        /// (only for the zero polynomial).
        /// There are some arithmetic expectations
        /// from the degree, for example, the degree
        /// of a product of polynomials is the summary
        /// of their degrees.
        /// Such an equality can not be defined using
        /// integers only.
        /// This class should provide a representation
        /// for polynomial degree with implementation
        /// for arithmetic operators that provides
        /// expected results
        #[repr(C)]
        #[derive(Debug)]
        pub struct PolynomialDegree {
            pub degree_: root::Algebra::PolynomialDegree_integral_t,
        }
        pub type PolynomialDegree_integral_t = ::std::os::raw::c_longlong;
        extern "C" {
            /// @brief   Checks if the degree is an integer (not \f$ -\infty \f$)
            /// @return  True iff the degree is an integer
            #[link_name = "\u{1}isInteger"]
            pub fn PolynomialDegree_isInteger(this: *const root::Algebra::PolynomialDegree)
                -> bool;
        }
        extern "C" {
            /// @brief   Constructor of degree from an integer
            /// @param   degree, if non-negative construct a
            /// PolynomialDegree with same value, otherwise
            /// constructs the \f$ -\infty \f$ degree
            #[link_name = "\u{1}PolynomialDegree"]
            pub fn PolynomialDegree_PolynomialDegree(
                this: *mut root::Algebra::PolynomialDegree,
                degree: root::Algebra::PolynomialDegree_integral_t,
            );
        }
        impl PolynomialDegree {
            #[inline]
            pub unsafe fn isInteger(&self) -> bool {
                PolynomialDegree_isInteger(self)
            }
            #[inline]
            pub unsafe fn new(degree: root::Algebra::PolynomialDegree_integral_t) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                PolynomialDegree_PolynomialDegree(&mut __bindgen_tmp, degree);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        pub struct multivarFunc__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct multivarFunc {
            pub vtable_: *const multivarFunc__bindgen_vtable,
        }
        #[repr(C)]
        pub struct MappingsSys__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct MappingsSys {
            pub vtable_: *const MappingsSys__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}getLinearComb"]
            pub fn MappingsSys_getLinearComb(
                this: *mut ::std::os::raw::c_void,
                coeffs: *const root::std::vector,
            ) -> *mut root::Algebra::multivarFunc;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PolynomialInterface {
            pub _base: root::Algebra::multivarFunc,
        }
    }
    pub mod libstark {
        #[allow(unused_imports)]
        use self::super::super::root;
        /// @class ConstraintSys
        /// @brief An interface for representation of system of constraints.
        ///
        /// A constraint system \f$ \mathcal{C} \f$ is a set of multivariate polynomials over
        /// some variables set \f$ \mathcal{U} \f$ .
        ///
        /// We say that an assignment \f$ \alpha:\mathcal{U} \to \mathbb{F} \f$ satisfies
        /// \f$ \mathcal{C} \f$ if and only if \f$ \forall p \in \mathcal{C} : p\left(\alpha\right)=0 \f$.
        ///
        /// For a given constraints system \f$ \mathcal{C} \f$ and a variables set \f$ \mathcal{V} \f$
        /// we define \f$ \mathcal{V}\left(\mathcal{C}\right)\subset\mathcal{V} \f$ as the
        /// set of all variables \f$ v \f$ that are used in \f$ \mathcal{C} \f$ (it will be useful
        /// later for performance, when we notice some constraint systems use
        /// only a fraction of the variables set).
        #[repr(C)]
        #[derive(Debug)]
        pub struct ConstraintSys {
            pub _base: root::Algebra::MappingsSys,
        }
        pub type ConstraintSys_polyPtr_t = root::std::unique_ptr;
        pub type ConstraintSys_polySet_t = root::std::vector;
        extern "C" {
            /// verifies if the constraint system is satisfied by given assignment
            #[link_name = "\u{1}verify"]
            pub fn ConstraintSys_verify(
                this: *const root::libstark::ConstraintSys,
                assignment: *const root::std::vector,
            ) -> bool;
        }
        extern "C" {
            /// get maximal degree of a polynomial in the system
            #[link_name = "\u{1}getMaximalDegree"]
            pub fn ConstraintSys_getMaximalDegree(
                this: *const root::libstark::ConstraintSys,
            ) -> root::Algebra::PolynomialDegree;
        }
        impl ConstraintSys {
            #[inline]
            pub unsafe fn verify(&self, assignment: *const root::std::vector) -> bool {
                ConstraintSys_verify(self, assignment)
            }
            #[inline]
            pub unsafe fn getMaximalDegree(&self) -> root::Algebra::PolynomialDegree {
                ConstraintSys_getMaximalDegree(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}numMappings"]
            pub fn ConstraintSys_numMappings(this: *mut ::std::os::raw::c_void) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}eval"]
            pub fn ConstraintSys_eval(
                this: *mut ::std::os::raw::c_void,
                assignment: *const root::std::vector,
            ) -> root::std::vector;
        }
        extern "C" {
            #[link_name = "\u{1}getLinearComb"]
            pub fn ConstraintSys_getLinearComb(
                this: *mut ::std::os::raw::c_void,
                coeffs: *const root::std::vector,
            ) -> *mut root::Algebra::PolynomialInterface;
        }
        extern "C" {
            /// return false only if the variable with given ID does not affect any constraint polynomial
            #[link_name = "\u{1}varUsed"]
            pub fn ConstraintSys_varUsed(this: *mut ::std::os::raw::c_void, varId: usize) -> bool;
        }
        #[repr(C)]
        pub struct Sequence__bindgen_vtable(::std::os::raw::c_void);
        /// @class Sequence
        /// @brief An interface class for sequences for some type T
        #[repr(C)]
        #[derive(Debug)]
        pub struct Sequence {
            pub vtable_: *const Sequence__bindgen_vtable,
        }
        pub type Sequence_index_t = u64;
        /// @class BairInstance
        /// @brief class for Bair instance
        ///
        /// A Bair instance is a tuple \f$(\mathbb{F},d,\mathcal{V},\mathcal{C}_\mathcal{A}, \mathcal{C}_\pi, B, padding_\pi)\f$ such that:
        ///
        /// \f$\mathbb{F}\f$ is a field with characteristic 2.
        ///
        /// \f$ d \in \mathbb{N} \f$ is the domain size indicator, we define the domain \f$ \mathcal{D} = \{0 \dots 2^d-2\} \f$.
        ///
        /// \f$ \mathcal{V} \times \{0,1\} \f$ is the variables set over which the constraint systems are defined.
        ///
        /// \f$ \mathcal{C}_\mathcal{A} \f$ is the constraint system (ConstraintSys) for the assignment \f$ \mathcal{A} \f$.
        ///
        /// \f$ \mathcal{C}_\pi \f$ is the constraint system (ConstraintSys) for the permutation \f$ \pi \f$.
        ///
        /// \f$ B \in (\mathcal{D} \times \mathcal{V}) \times \mathbb{F} \f$ is the set of boundary constraints
        ///
        /// \f$ padding_\pi \in \mathbb{F}^\mathcal{V} \f$ is a hint, that is not verified, but will be explained later
        ///
        /// For two assignments \f$ \alpha , \beta : \mathcal{V} \to \mathbb{F} \f$ we define \f$ (\alpha,\beta):\mathcal{V} \times\{0,1\} \to \mathbb{F} \f$ by:
        /// \f[
        /// [(\alpha,\beta)](v,i) =
        /// \begin{cases}
        /// \alpha\left(v\right) & i=0\\
        /// \beta\left(v\right) & i=1
        /// \end{cases}
        /// \f]
        ///
        /// A Bair instance \f$(\mathbb{F},d,\mathcal{V},\mathcal{C}_\mathcal{A}, \mathcal{C}_\pi, B)\f$
        /// is satisfiable if and only if there exists:
        ///
        /// \f$ \mathcal{A} : \mathcal{D} \to (\mathcal{V} \to \mathbb{F}) \f$ which is called the assignment
        ///
        /// \f$ \pi : \mathcal{D} \to \mathcal {D} \f$ which is called the permutation
        ///
        /// such that the following constraints hold:
        ///
        /// Assignment constraints satisfaction:
        /// \f[
        /// \forall n \in \mathcal{D} \setminus \{ 2^d - 2 \}, \forall p \in \mathcal{C}_\mathcal{A} : p(\mathcal{A}(n), \mathcal{A}(n+1)) = 0
        /// \f]
        ///
        /// Permutation constraints satisfaction:
        /// \f[
        /// \begin{align*}
        /// \left[\mathcal{V}\times\left\{ 1\right\} \right]\left(\mathcal{C}_\pi\right)\neq\emptyset\Rightarrow & \pi \in S_\mathcal{D}\text{ (meaning it is a permutation)}\\
        /// \forall n \in \mathcal{D} \setminus \{2^d -2 \},\forall p \in \mathcal{C}_\pi : & p\left(\mathcal{A} \left(n\right),\mathcal{A} \left( \pi \left(n\right)\right)\right)=0
        /// \end{align*}
        /// \f]
        ///
        /// The \f $padding_\pi \f$ hint is a vector such that \f$ \forall \alpha \in \mathbb{F}^\mathcal{V} \f$ it holds that:
        /// \f$ \exists p \in \mathcal{C}_\pi : & p\left(\alpha,padding_\pi \right) \ne 0 \f$
        ///
        /// Boundary constraints:
        /// \f[
        /// \forall ((x,y),\alpha) \in B : [\mathcal{A}(x)](y) = \alpha
        /// \f]
        ///
        /// In the code we give more descriptive names:
        /// we name \f$ \mathbb{F} \f$ as 'contextField' \n
        /// we name \f$ d \f$ as 'domainSizeIndicator' \n
        /// we name the cardinality \f$ | \mathcal{D} | \f$ as 'domainSize' \n
        /// we define \f$ \mathcal{V} = \{ 0 \dots \text{'vectorsLen'} \}\f$ \n
        /// we name \f$ \mathcal{C}_\mathcal{A} \f$ as 'constraintsAssignment' \n
        /// we name \f$ \mathcal{C}_\pi \f$ as 'constraintsPermutation' \n
        /// we name \f$ B \f$ as 'boundaryConstraints' \n
        ///
        ///
        /// Methods:\n
        /// Instance class contains only getters,
        /// constructor and a destructor.
        #[repr(C)]
        pub struct BairInstance {
            pub vectorsLen_: usize,
            pub domainSizeIndicator_: ::std::os::raw::c_short,
            pub constraintsAssignment_: root::libstark::BairInstance_constraintsPtr_t,
            pub constraintsPermutation_: root::libstark::BairInstance_constraintsPtr_t,
            pub boundaryConstraints_: root::libstark::BairInstance_boundaryConstraints_t,
            pub paddingPi_: root::std::vector,
        }
        pub type BairInstance_constraintsPtr_t = root::std::unique_ptr;
        pub type BairInstance_point_t = root::std::pair<usize, usize>;
        pub type BairInstance_boundaryConstraints_t = root::std::map;
        pub type BairInstance_permutation_t = root::libstark::Sequence;
        /// @class BairWitness
        /// @brief class for Bair Witness
        ///
        /// A Bair witness for Bair instance \f$(\mathbb{F},d,\mathcal{V},\mathcal{C}_\mathcal{A}, \mathcal{C}_\pi, B)\f$
        /// is a pair \f$ (\mathcal{A},\pi) \f$ such that:
        ///
        /// \f$ \mathcal{A} : \mathcal{D} \to (\mathcal{V} \to \mathbb{F}) \f$ which is called the assignment
        ///
        /// \f$ \pi : \mathcal{D} \to \mathcal {D} \f$ which is called the permutation
        ///
        /// For two assignments \f$ \alpha , \beta : \mathcal{V} \to \mathbb{F} \f$ we define \f$ (\alpha,\beta):\mathcal{V} \times\{0,1\} \to \mathbb{F} \f$ by:
        /// \f[
        /// [(\alpha,\beta)](v,i) =
        /// \begin{cases}
        /// \alpha\left(v\right) & i=0\\
        /// \beta\left(v\right) & i=1
        /// \end{cases}
        /// \f]
        ///
        /// It said that a Bair instance \f$(\mathbb{F},d,\mathcal{V},\mathcal{C}_\mathcal{A}, \mathcal{C}_\pi, B)\f$
        /// is satisfied by a Bair witness \f$ (\mathcal{A},\pi) \f$ the following constraints hold:
        ///
        /// Assignment constraints satisfaction:
        /// \f[
        /// \forall n \in \mathcal{D} \setminus \{ 2^d - 2 \}, \forall p \in \mathcal{C}_\mathcal{A} : p(\mathcal{A}(n), \mathcal{A}(n+1)) = 0
        /// \f]
        ///
        /// Permutation constraints satisfaction:
        /// \f[
        /// \begin{align*}
        /// \left[\mathcal{V}\times\left\{ 1\right\} \right]\left(\mathcal{C}_\pi\right)\neq\emptyset\Rightarrow & \pi \in S_\mathcal{D}\text{ (meaning it is a permutation)}\\
        /// \forall n \in \mathcal{D} \setminus \{2^d -2 \},\forall p \in \mathcal{C}_\pi : & p\left(\mathcal{A} \left(n\right),\mathcal{A} \left( \pi \left(n\right)\right)\right)=0
        /// \end{align*}
        /// \f]
        ///
        /// Boundary constraints:
        /// \f[
        /// \forall ((x,y),\alpha) \in B : [\mathcal{A}(x)](y) = \alpha
        /// \f]
        ///
        /// In the code we give more descriptive names:
        ///
        /// we name \f$ \mathcal{A} \f$ as 'get_assignment' \n
        /// we name \f$ \pi \f$ as 'permutation' \n
        ///
        ///
        /// Methods:\n
        /// Instance class contains only getters,
        /// constructor and a destructor.
        #[repr(C)]
        #[derive(Debug)]
        pub struct BairWitness {
            pub assignment_: root::libstark::BairWitness_assignment_ptr,
            pub permutation_: root::libstark::BairWitness_permutation_ptr,
        }
        pub type BairWitness_color_t = root::std::vector;
        pub type BairWitness_assignment_t = root::libstark::Sequence;
        pub type BairWitness_assignment_ptr = root::std::unique_ptr;
        pub type BairWitness_permutation_t = root::libstark::Sequence;
        pub type BairWitness_permutation_ptr = root::std::unique_ptr;
        pub mod Protocols {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct TranscriptMessage__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct TranscriptMessage {
                pub vtable_: *const TranscriptMessage__bindgen_vtable,
            }
            pub type msg_ptr_t = root::std::unique_ptr;
            #[repr(C)]
            pub struct PartieInterface__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct PartieInterface {
                pub vtable_: *const PartieInterface__bindgen_vtable,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct verifierInterface {
                pub _base: root::libstark::Protocols::PartieInterface,
            }
            extern "C" {
                pub fn executeProtocol(
                    prover: *mut root::libstark::Protocols::PartieInterface,
                    verifier: *mut root::libstark::Protocols::verifierInterface,
                    onlyVerifierData: bool,
                ) -> bool;
            }
        }
    }
}
